// SPDX-License-Identifier: MIT
pragma solidity ^0.7.0;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/Counters.sol";
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";

contract CryptoGogos is ERC721, Ownable {
    using Counters for Counters.Counter;
    Counters.Counter private _tokenIds; //Counter is a struct in the Counters library

    uint256 private constant maxSupply = 7777;

    constructor() public ERC721("GOGOS", "GOG") {}

    /**
     * @dev Gets current gogo Price
     */
    function getNFTPrice() public view returns (uint256) {
        uint256 currentSupply = totalSupply();

        if (currentSupply >= 7150) {
            return 1 ether;
        } else if (currentSupply >= 3150) {
            return 0.2 ether;
        } else if (currentSupply >= 650) {
            return 0.15 ether;
        } else if (currentSupply >= 150) {
            return 0.1 ether;
        } else if (currentSupply >= 75) {
            return 0.07 ether;
        } else {
            return 0.05 ether;
        }
    }

    /**
     * @dev Creates a new token for `to`. Its token ID will be automatically
     * assigned (and available on the emitted {IERC721-Transfer} event), and the token
     * URI autogenerated based on the base URI passed at construction.
     *
     *
     * Requirements:
     *
     * - the caller must have the `MINTER_ROLE`.
     */
    function mintByAdmin(address to, string memory _tokenURI) public onlyOwner {
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        require(newItemId <= maxSupply);
        _mint(to, newItemId);
        _setTokenURI(newItemId, _tokenURI);
    }

    /*
        recepient is the address of the person who will receive nft
        hash is IPFS hash associated with nft
        metadata is link to json
    */
    function mint(string memory _tokenURI) public payable returns (uint256) {
        require(getNFTPrice() == msg.value, "Ether value sent is not correct");
        _tokenIds.increment();
        uint256 newItemId = _tokenIds.current();
        require(newItemId <= maxSupply);
        _mint(msg.sender, newItemId);
        _setTokenURI(newItemId, _tokenURI);
        return newItemId;
    }

    /**
     * @dev Withdraw ether from this contract (Callable by owner)
     */
    function withdraw() external onlyOwner {
        uint256 balance = address(this).balance;
        msg.sender.transfer(balance);
    }
}
